Backport of https://github.com/OSGeo/gdal/pull/6208

diff --git a/autotest/cpp/test_cpl.cpp b/autotest/cpp/test_cpl.cpp
index e89d5f8646..4c22cc3f05 100644
--- a/gdalautotest-3.5.1/cpp/test_cpl.cpp
+++ b/gdalautotest-3.5.1/cpp/test_cpl.cpp
@@ -3728,6 +3728,78 @@ namespace tut
         ensure(VSIFOpenL("/vsimyplugin/i_dont_exist", "rb") == nullptr);
     }
 
+    // Test VSIIsLocal()
+    template<>
+    template<>
+    void object::test<58>()
+    {
+        ensure(VSIIsLocal("/vsimem/"));
+        ensure(VSIIsLocal("/vsigzip//vsimem/tmp.gz"));
+#ifdef HAVE_CURL
+        ensure(!VSIIsLocal("/vsicurl/http://example.com"));
+#endif
+        VSIStatBufL sStat;
+#ifdef _WIN32
+        if( VSIStatL("c:\\", &sStat) == 0 )
+            ensure(VSIIsLocal("c:\\i_do_not_exist"));
+#else
+        if( VSIStatL("/tmp", &sStat) == 0 )
+            ensure(VSIIsLocal("/tmp/i_do_not_exist"));
+#endif
+    }
+
+    // Test VSISupportsSequentialWrite()
+    template<>
+    template<>
+    void object::test<59>()
+    {
+        ensure(VSISupportsSequentialWrite("/vsimem/", false));
+#ifdef HAVE_CURL
+        ensure(!VSISupportsSequentialWrite("/vsicurl/http://example.com", false));
+        ensure(VSISupportsSequentialWrite("/vsis3/test_bucket/", false));
+#endif
+        ensure(VSISupportsSequentialWrite("/vsigzip//vsimem/tmp.gz", false));
+#ifdef HAVE_CURL
+        ensure(!VSISupportsSequentialWrite("/vsigzip//vsicurl/http://example.com/tmp.gz", false));
+#endif
+        VSIStatBufL sStat;
+#ifdef _WIN32
+        if( VSIStatL("c:\\", &sStat) == 0 )
+            ensure(VSISupportsSequentialWrite("c:\\", false));
+#else
+        if( VSIStatL("/tmp", &sStat) == 0 )
+            ensure(VSISupportsSequentialWrite("/tmp/i_do_not_exist", false));
+#endif
+    }
+
+    // Test VSISupportsRandomWrite()
+    template<>
+    template<>
+    void object::test<60>()
+    {
+        ensure(VSISupportsRandomWrite("/vsimem/", false));
+#ifdef HAVE_CURL
+        ensure(!VSISupportsRandomWrite("/vsicurl/http://example.com", false));
+        ensure(!VSISupportsRandomWrite("/vsis3/test_bucket/", false));
+        ensure(!VSISupportsRandomWrite("/vsis3/test_bucket/", true));
+        CPLSetConfigOption("CPL_VSIL_USE_TEMP_FILE_FOR_RANDOM_WRITE", "YES");
+        ensure(!VSISupportsRandomWrite("/vsis3/test_bucket/", true));
+        CPLSetConfigOption("CPL_VSIL_USE_TEMP_FILE_FOR_RANDOM_WRITE", nullptr);
+#endif
+        ensure(!VSISupportsRandomWrite("/vsigzip//vsimem/tmp.gz", false));
+#ifdef HAVE_CURL
+        ensure(!VSISupportsRandomWrite("/vsigzip//vsicurl/http://example.com/tmp.gz", false));
+#endif
+        VSIStatBufL sStat;
+#ifdef _WIN32
+        if( VSIStatL("c:\\", &sStat) == 0 )
+            ensure(VSISupportsRandomWrite("c:\\", false));
+#else
+        if( VSIStatL("/tmp", &sStat) == 0 )
+            ensure(VSISupportsRandomWrite("/tmp", false));
+#endif
+    }
+
     // WARNING: keep that line at bottom and read carefully:
     // If the number of tests reaches 100, increase the MAX_NUMBER_OF_TESTS
     // define at top of this file (and update this comment!)
diff --git a/frmts/gtiff/cogdriver.cpp b/frmts/gtiff/cogdriver.cpp
index c3c1c3e4c5..9105a3e96d 100644
--- a/frmts/gtiff/cogdriver.cpp
+++ b/frmts/gtiff/cogdriver.cpp
@@ -73,8 +73,17 @@ static bool HasZSTDCompression()
 static CPLString GetTmpFilename(const char* pszFilename,
                                 const char* pszExt)
 {
+    const bool bSupportsRandomWrite = VSISupportsRandomWrite(pszFilename, false);
     CPLString osTmpFilename;
-    osTmpFilename.Printf("%s.%s", pszFilename, pszExt);
+    if( !bSupportsRandomWrite ||
+        CPLGetConfigOption( "CPL_TMPDIR", nullptr ) != nullptr )
+    {
+        osTmpFilename = CPLGenerateTempFilename(CPLGetBasename(pszFilename));
+    }
+    else
+        osTmpFilename = pszFilename;
+    osTmpFilename += '.';
+    osTmpFilename += pszExt;
     VSIUnlink(osTmpFilename);
     return osTmpFilename;
 }
diff --git a/frmts/stacta/stactadataset.cpp b/frmts/stacta/stactadataset.cpp
index 24f91789b5..5ac62197ba 100644
--- a/frmts/stacta/stactadataset.cpp
+++ b/frmts/stacta/stactadataset.cpp
@@ -452,8 +452,7 @@ CPLErr STACTARawDataset::IRasterIO( GDALRWFlag eRWFlag,
                     aosAllowedDrivers.AddString("JP2MrSID");
                     aosAllowedDrivers.AddString("JP2OpenJPEG");
                     if( bDownloadWholeMetaTile &&
-                        (STARTS_WITH(osURL, "/vsis3/") ||
-                        STARTS_WITH(osURL, "/vsicurl/")) )
+                        !VSIIsLocal(osURL.c_str()) )
                     {
                         if( m_poMasterDS->m_bSkipMissingMetaTile )
                             CPLPushErrorHandler(CPLQuietErrorHandler);
diff --git a/frmts/tiledb/tiledbdataset.cpp b/frmts/tiledb/tiledbdataset.cpp
index 7b7f4e3bc3..a454ca4975 100644
--- a/frmts/tiledb/tiledbdataset.cpp
+++ b/frmts/tiledb/tiledbdataset.cpp
@@ -872,7 +872,7 @@ CPLErr TileDBDataset::TrySaveXML()
                 eErr = TrySaveXML();
             }
             /* No way we can save into a /vsicurl resource */
-            else if( !STARTS_WITH(psPam->pszPamFilename, "/vsicurl") )
+            else if( !VSISupportsSequentialWrite(psPam->pszPamFilename, false) )
             {
                 CPLError( CE_Warning, CPLE_AppDefined,
                         "Unable to save auxiliary information in %s.",
diff --git a/gcore/gdal_misc.cpp b/gcore/gdal_misc.cpp
index 41660cfdc4..0c3dd0a7f7 100644
--- a/gcore/gdal_misc.cpp
+++ b/gcore/gdal_misc.cpp
@@ -4226,9 +4226,7 @@ bool GDALCanReliablyUseSiblingFileList(const char* pszFilename)
             // non-ASCII character found
 
             // if this is a network storage, assume no issue
-            if( strstr(pszFilename, "/vsicurl/") ||
-                strstr(pszFilename, "/vsis3/") ||
-                strstr(pszFilename, "/vsicurl/") )
+            if( !VSIIsLocal(pszFilename) )
             {
                 return true;
             }
diff --git a/ogr/ogrsf_frmts/gml/ogrgmldatasource.cpp b/ogr/ogrsf_frmts/gml/ogrgmldatasource.cpp
index 156db6ae68..41b7c92049 100644
--- a/ogr/ogrsf_frmts/gml/ogrgmldatasource.cpp
+++ b/ogr/ogrsf_frmts/gml/ogrgmldatasource.cpp
@@ -1276,15 +1276,7 @@ bool OGRGMLDataSource::Open( GDALOpenInfo *poOpenInfo )
     if( EQUAL(pszWriteGFS, "AUTO") )
     {
         if( !bHaveSchema && !poReader->HasStoppedParsing() &&
-            !STARTS_WITH_CI(pszFilename, "/vsitar/") &&
-            !STARTS_WITH_CI(pszFilename, "/vsizip/") &&
-            !STARTS_WITH_CI(pszFilename, "/vsigzip/vsi") &&
-            !STARTS_WITH_CI(pszFilename, "/vsigzip//vsi") &&
-            !STARTS_WITH_CI(pszFilename, "/vsicurl") &&
-            !STARTS_WITH_CI(pszFilename, "/vsis3") &&
-            !STARTS_WITH_CI(pszFilename, "/vsigs") &&
-            !STARTS_WITH_CI(pszFilename, "/vsiaz") &&
-            !STARTS_WITH_CI(pszFilename, "/vsioss") )
+            VSIIsLocal(pszFilename) && VSISupportsSequentialWrite(pszFilename, false) )
         {
             VSIStatBufL sGFSStatBuf;
             if( VSIStatExL(osGFSFilename, &sGFSStatBuf, VSI_STAT_EXISTS_FLAG) != 0 )
diff --git a/port/cpl_vsi.h b/port/cpl_vsi.h
index d62cd46dff..5941246b98 100644
--- a/port/cpl_vsi.h
+++ b/port/cpl_vsi.h
@@ -35,6 +35,8 @@
 #include "cpl_port.h"
 #include "cpl_progress.h"
 
+#include <stdbool.h>
+
 /**
  * \file cpl_vsi.h
  *
@@ -219,6 +221,12 @@ int CPL_DLL     VSIIsCaseSensitiveFS( const char * pszFilename );
 
 int CPL_DLL     VSISupportsSparseFiles( const char* pszPath );
 
+bool CPL_DLL    VSIIsLocal( const char* pszPath );
+
+bool CPL_DLL    VSISupportsSequentialWrite( const char* pszPath, bool bAllowLocalTempFile );
+
+bool CPL_DLL    VSISupportsRandomWrite( const char* pszPath, bool bAllowLocalTempFile );
+
 int CPL_DLL     VSIHasOptimizedReadMultiRange( const char* pszPath );
 
 const char CPL_DLL *VSIGetActualURL( const char* pszFilename );
diff --git a/port/cpl_vsi_virtual.h b/port/cpl_vsi_virtual.h
index 00c25841e4..39448483ee 100644
--- a/port/cpl_vsi_virtual.h
+++ b/port/cpl_vsi_virtual.h
@@ -138,6 +138,10 @@ public:
     virtual bool    AbortPendingUploads(const char* /*pszFilename*/) { return true;}
 
     virtual std::string GetStreamingFilename(const std::string& osFilename) const { return osFilename; }
+
+    virtual bool    IsLocal( const char* /* pszPath */ ) { return true; }
+    virtual bool    SupportsSequentialWrite( const char* /* pszPath */, bool /* bAllowLocalTempFile */ ) { return true; }
+    virtual bool    SupportsRandomWrite( const char* /* pszPath */, bool /* bAllowLocalTempFile */ ) { return true; }
 };
 #endif /* #ifndef DOXYGEN_SKIP */
 
@@ -250,6 +254,10 @@ public:
     virtual char* SplitFilename(const char *pszFilename, CPLString &osFileInArchive, int bCheckMainFileExists);
     virtual VSIArchiveReader* OpenArchiveFile(const char* archiveFilename, const char* fileInArchiveName);
     virtual int FindFileInArchive(const char* archiveFilename, const char* fileInArchiveName, const VSIArchiveEntry** archiveEntry);
+
+    virtual bool    IsLocal( const char* pszPath ) override;
+    virtual bool    SupportsSequentialWrite( const char* /* pszPath */, bool /* bAllowLocalTempFile */ ) override { return false; }
+    virtual bool    SupportsRandomWrite( const char* /* pszPath */, bool /* bAllowLocalTempFile */ ) override { return false; }
 };
 
 /************************************************************************/
diff --git a/port/cpl_vsil.cpp b/port/cpl_vsil.cpp
index 60c608ccb5..1700854aa5 100644
--- a/port/cpl_vsil.cpp
+++ b/port/cpl_vsil.cpp
@@ -958,6 +958,85 @@ int VSISupportsSparseFiles( const char* pszPath )
     return poFSHandler->SupportsSparseFiles( pszPath );
 }
 
+/************************************************************************/
+/*                           VSIIsLocal()                               */
+/************************************************************************/
+
+/**
+ * \brief Returns if the file/filesystem is "local".
+ *
+ * The concept of local is mostly by opposition with a network / remote
+ * file system whose access time can be long.
+ *
+ * /vsimem/ is considered to be a local file system, although a non-persistent
+ * one.
+ *
+ * @param pszPath the path of the filesystem object to be tested.
+ * UTF-8 encoded.
+ *
+ * @return TRUE or FALSE
+ *
+ * @since GDAL 3.6
+ */
+
+bool VSIIsLocal( const char* pszPath )
+{
+    VSIFilesystemHandler *poFSHandler =
+        VSIFileManager::GetHandler( pszPath );
+
+    return poFSHandler->IsLocal( pszPath );
+}
+
+/************************************************************************/
+/*                      VSISupportsSequentialWrite()                    */
+/************************************************************************/
+
+/**
+ * \brief Returns if the filesystem supports sequential write.
+ *
+ * @param pszPath the path of the filesystem object to be tested.
+ * UTF-8 encoded.
+ * @param bAllowLocalTempFile whether the file system is allowed to use a
+ * local temporary file before uploading to the target location.
+ *
+ * @return TRUE or FALSE
+ *
+ * @since GDAL 3.6
+ */
+
+bool VSISupportsSequentialWrite( const char* pszPath, bool bAllowLocalTempFile )
+{
+    VSIFilesystemHandler *poFSHandler =
+        VSIFileManager::GetHandler( pszPath );
+
+    return poFSHandler->SupportsSequentialWrite( pszPath, bAllowLocalTempFile );
+}
+
+/************************************************************************/
+/*                      VSISupportsRandomWrite()                        */
+/************************************************************************/
+
+/**
+ * \brief Returns if the filesystem supports random write.
+ *
+ * @param pszPath the path of the filesystem object to be tested.
+ * UTF-8 encoded.
+ * @param bAllowLocalTempFile whether the file system is allowed to use a
+ * local temporary file before uploading to the target location.
+ *
+ * @return TRUE or FALSE
+ *
+ * @since GDAL 3.6
+ */
+
+bool VSISupportsRandomWrite( const char* pszPath, bool bAllowLocalTempFile )
+{
+    VSIFilesystemHandler *poFSHandler =
+        VSIFileManager::GetHandler( pszPath );
+
+    return poFSHandler->SupportsRandomWrite( pszPath, bAllowLocalTempFile );
+}
+
 /************************************************************************/
 /*                     VSIHasOptimizedReadMultiRange()                  */
 /************************************************************************/
diff --git a/port/cpl_vsil_abstract_archive.cpp b/port/cpl_vsil_abstract_archive.cpp
index 9cf66e6fdb..c27e1e274f 100644
--- a/port/cpl_vsil_abstract_archive.cpp
+++ b/port/cpl_vsil_abstract_archive.cpp
@@ -884,4 +884,18 @@ char** VSIArchiveFilesystemHandler::ReadDirEx( const char *pszDirname,
     return oDir.StealList();
 }
 
+/************************************************************************/
+/*                               IsLocal()                              */
+/************************************************************************/
+
+bool VSIArchiveFilesystemHandler::IsLocal( const char* pszPath )
+{
+    if( !STARTS_WITH(pszPath, GetPrefix()) )
+        return false;
+    const char* pszBaseFileName = pszPath + strlen(GetPrefix());
+    VSIFilesystemHandler *poFSHandler =
+        VSIFileManager::GetHandler(pszBaseFileName);
+    return poFSHandler->IsLocal(pszPath);
+}
+
 //! @endcond
diff --git a/port/cpl_vsil_adls.cpp b/port/cpl_vsil_adls.cpp
index fc750f1fba..a780c342e4 100644
--- a/port/cpl_vsil_adls.cpp
+++ b/port/cpl_vsil_adls.cpp
@@ -236,6 +236,9 @@ class VSIADLSFSHandler final : public IVSIS3LikeFSHandler
     // Multipart upload (mapping of S3 interface)
     bool SupportsParallelMultipartUpload() const override { return true; }
 
+    bool SupportsSequentialWrite( const char* /* pszPath */, bool /* bAllowLocalTempFile */ ) override { return true; }
+    bool SupportsRandomWrite( const char* /* pszPath */, bool /* bAllowLocalTempFile */ ) override;
+
     CPLString InitiateMultipartUpload(
                                 const std::string& osFilename,
                                 IVSIS3LikeHandleHelper * poS3HandleHelper,
@@ -1194,8 +1197,7 @@ VSIVirtualHandle* VSIADLSFSHandler::Open( const char *pszFilename,
 
     if( strchr(pszAccess, 'w') != nullptr || strchr(pszAccess, 'a') != nullptr )
     {
-        if( strchr(pszAccess, '+') != nullptr &&
-            !CPLTestBool(CPLGetConfigOption("CPL_VSIL_USE_TEMP_FILE_FOR_RANDOM_WRITE", "NO")) )
+        if( strchr(pszAccess, '+') != nullptr && !SupportsRandomWrite(pszFilename, true) )
         {
             CPLError(CE_Failure, CPLE_AppDefined,
                         "w+ not supported for /vsiadls, unless "
@@ -1226,6 +1228,16 @@ VSIVirtualHandle* VSIADLSFSHandler::Open( const char *pszFilename,
         VSICurlFilesystemHandlerBase::Open(pszFilename, pszAccess, bSetError, papszOptions);
 }
 
+/************************************************************************/
+/*                        SupportsRandomWrite()                         */
+/************************************************************************/
+
+bool VSIADLSFSHandler::SupportsRandomWrite( const char* /* pszPath */, bool bAllowLocalTempFile )
+{
+    return bAllowLocalTempFile &&
+           CPLTestBool(CPLGetConfigOption("CPL_VSIL_USE_TEMP_FILE_FOR_RANDOM_WRITE", "NO"));
+}
+
 /************************************************************************/
 /*                          GetURLFromFilename()                        */
 /************************************************************************/
diff --git a/port/cpl_vsil_az.cpp b/port/cpl_vsil_az.cpp
index 007293db1e..5d61336ece 100644
--- a/port/cpl_vsil_az.cpp
+++ b/port/cpl_vsil_az.cpp
@@ -546,6 +546,9 @@ class VSIAzureFSHandler final : public IVSIS3LikeFSHandler
 
     bool SupportsParallelMultipartUpload() const override { return true; }
 
+    bool SupportsSequentialWrite( const char* /* pszPath */, bool /* bAllowLocalTempFile */ ) override { return true; }
+    bool SupportsRandomWrite( const char* /* pszPath */, bool /* bAllowLocalTempFile */ ) override;
+
     CPLString InitiateMultipartUpload(
                                 const std::string& /* osFilename */ ,
                                 IVSIS3LikeHandleHelper *,
@@ -1297,8 +1300,7 @@ VSIVirtualHandle* VSIAzureFSHandler::Open( const char *pszFilename,
 
     if( strchr(pszAccess, 'w') != nullptr || strchr(pszAccess, 'a') != nullptr )
     {
-        if( strchr(pszAccess, '+') != nullptr &&
-            !CPLTestBool(CPLGetConfigOption("CPL_VSIL_USE_TEMP_FILE_FOR_RANDOM_WRITE", "NO")) )
+        if( strchr(pszAccess, '+') != nullptr && !SupportsRandomWrite(pszFilename, true) )
         {
             CPLError(CE_Failure, CPLE_AppDefined,
                         "w+ not supported for /vsiaz, unless "
@@ -1324,6 +1326,16 @@ VSIVirtualHandle* VSIAzureFSHandler::Open( const char *pszFilename,
         VSICurlFilesystemHandlerBase::Open(pszFilename, pszAccess, bSetError, papszOptions);
 }
 
+/************************************************************************/
+/*                        SupportsRandomWrite()                         */
+/************************************************************************/
+
+bool VSIAzureFSHandler::SupportsRandomWrite( const char* /* pszPath */, bool bAllowLocalTempFile )
+{
+    return bAllowLocalTempFile &&
+           CPLTestBool(CPLGetConfigOption("CPL_VSIL_USE_TEMP_FILE_FOR_RANDOM_WRITE", "NO"));
+}
+
 /************************************************************************/
 /*                          GetURLFromFilename()                        */
 /************************************************************************/
diff --git a/port/cpl_vsil_curl_class.h b/port/cpl_vsil_curl_class.h
index b30c03fadc..dbc486dc04 100644
--- a/port/cpl_vsil_curl_class.h
+++ b/port/cpl_vsil_curl_class.h
@@ -277,6 +277,10 @@ public:
     virtual CPLString GetFSPrefix() const = 0;
     virtual bool      AllowCachedDataFor(const char* pszFilename);
 
+    virtual bool    IsLocal( const char* /* pszPath */ ) override { return false; }
+    virtual bool    SupportsSequentialWrite( const char* /* pszPath */, bool /* bAllowLocalTempFile */ ) override { return false; }
+    virtual bool    SupportsRandomWrite( const char* /* pszPath */, bool /* bAllowLocalTempFile */ ) override { return false; }
+
     std::shared_ptr<std::string> GetRegion( const char* pszURL,
                                    vsi_l_offset nFileOffsetStart );
 
diff --git a/port/cpl_vsil_gs.cpp b/port/cpl_vsil_gs.cpp
index a262e6ef0e..314164ba4c 100644
--- a/port/cpl_vsil_gs.cpp
+++ b/port/cpl_vsil_gs.cpp
@@ -99,6 +99,9 @@ class VSIGSFSHandler final : public IVSIS3LikeFSHandler
     // Multipart upload
     bool SupportsParallelMultipartUpload() const override { return true; }
 
+    bool SupportsSequentialWrite( const char* /* pszPath */, bool /* bAllowLocalTempFile */ ) override { return true; }
+    bool SupportsRandomWrite( const char* /* pszPath */, bool /* bAllowLocalTempFile */ ) override;
+
     char** GetFileMetadata( const char * pszFilename, const char* pszDomain,
                             CSLConstList papszOptions ) override;
 
@@ -182,8 +185,7 @@ VSIVirtualHandle* VSIGSFSHandler::Open( const char *pszFilename,
 
     if( strchr(pszAccess, 'w') != nullptr || strchr(pszAccess, 'a') != nullptr )
     {
-        if( strchr(pszAccess, '+') != nullptr &&
-            !CPLTestBool(CPLGetConfigOption("CPL_VSIL_USE_TEMP_FILE_FOR_RANDOM_WRITE", "NO")) )
+        if( strchr(pszAccess, '+') != nullptr && !SupportsRandomWrite(pszFilename, true) )
         {
             CPLError(CE_Failure, CPLE_AppDefined,
                         "w+ not supported for /vsigs, unless "
@@ -215,6 +217,16 @@ VSIVirtualHandle* VSIGSFSHandler::Open( const char *pszFilename,
         VSICurlFilesystemHandlerBase::Open(pszFilename, pszAccess, bSetError, papszOptions);
 }
 
+/************************************************************************/
+/*                        SupportsRandomWrite()                         */
+/************************************************************************/
+
+bool VSIGSFSHandler::SupportsRandomWrite( const char* /* pszPath */, bool bAllowLocalTempFile )
+{
+    return bAllowLocalTempFile &&
+           CPLTestBool(CPLGetConfigOption("CPL_VSIL_USE_TEMP_FILE_FOR_RANDOM_WRITE", "NO"));
+}
+
 /************************************************************************/
 /*                           GetOptions()                               */
 /************************************************************************/
diff --git a/port/cpl_vsil_gzip.cpp b/port/cpl_vsil_gzip.cpp
index e452714586..6e35519aab 100644
--- a/port/cpl_vsil_gzip.cpp
+++ b/port/cpl_vsil_gzip.cpp
@@ -254,6 +254,9 @@ public:
 
     const char* GetOptions() override;
 
+    virtual bool    SupportsSequentialWrite( const char* pszPath, bool bAllowLocalTempFile ) override;
+    virtual bool    SupportsRandomWrite( const char* /* pszPath */, bool /* bAllowLocalTempFile */ ) override { return false; }
+
     void SaveInfo( VSIGZipHandle* poHandle );
     void SaveInfo_unlocked( VSIGZipHandle* poHandle );
 };
@@ -2204,6 +2207,20 @@ VSIVirtualHandle* VSIGZipFilesystemHandler::Open( const char *pszFilename,
     return nullptr;
 }
 
+/************************************************************************/
+/*                      SupportsSequentialWrite()                       */
+/************************************************************************/
+
+bool VSIGZipFilesystemHandler::SupportsSequentialWrite( const char* pszPath, bool bAllowLocalTempFile )
+{
+    if( !STARTS_WITH_CI(pszPath, "/vsigzip/") )
+        return pszPath;
+    const char* pszBaseFileName = pszPath + strlen("/vsigzip/");
+    VSIFilesystemHandler *poFSHandler =
+        VSIFileManager::GetHandler(pszBaseFileName);
+    return poFSHandler->SupportsSequentialWrite(pszPath, bAllowLocalTempFile);
+}
+
 /************************************************************************/
 /*                          OpenGZipReadOnly()                          */
 /************************************************************************/
diff --git a/port/cpl_vsil_oss.cpp b/port/cpl_vsil_oss.cpp
index a53e9bf303..ff68920377 100644
--- a/port/cpl_vsil_oss.cpp
+++ b/port/cpl_vsil_oss.cpp
@@ -101,6 +101,9 @@ public:
     char* GetSignedURL( const char* pszFilename, CSLConstList papszOptions ) override;
 
     std::string GetStreamingFilename(const std::string& osFilename) const override { return osFilename; }
+
+    bool SupportsSequentialWrite( const char* /* pszPath */, bool /* bAllowLocalTempFile */ ) override { return true; }
+    bool SupportsRandomWrite( const char* /* pszPath */, bool /* bAllowLocalTempFile */ ) override;
 };
 
 /************************************************************************/
@@ -140,8 +143,7 @@ VSIVirtualHandle* VSIOSSFSHandler::Open( const char *pszFilename,
 
     if( strchr(pszAccess, 'w') != nullptr || strchr(pszAccess, 'a') != nullptr )
     {
-        if( strchr(pszAccess, '+') != nullptr &&
-            !CPLTestBool(CPLGetConfigOption("CPL_VSIL_USE_TEMP_FILE_FOR_RANDOM_WRITE", "NO")) )
+        if( strchr(pszAccess, '+') != nullptr && !SupportsRandomWrite(pszFilename, true) )
         {
             CPLError(CE_Failure, CPLE_AppDefined,
                         "w+ not supported for /vsioss, unless "
@@ -174,6 +176,16 @@ VSIVirtualHandle* VSIOSSFSHandler::Open( const char *pszFilename,
         VSICurlFilesystemHandlerBase::Open(pszFilename, pszAccess, bSetError, papszOptions);
 }
 
+/************************************************************************/
+/*                        SupportsRandomWrite()                         */
+/************************************************************************/
+
+bool VSIOSSFSHandler::SupportsRandomWrite( const char* /* pszPath */, bool bAllowLocalTempFile )
+{
+    return bAllowLocalTempFile &&
+           CPLTestBool(CPLGetConfigOption("CPL_VSIL_USE_TEMP_FILE_FOR_RANDOM_WRITE", "NO"));
+}
+
 /************************************************************************/
 /*                       ~VSIOSSFSHandler()                             */
 /************************************************************************/
diff --git a/port/cpl_vsil_s3.cpp b/port/cpl_vsil_s3.cpp
index 5244aee2bc..4c9755c482 100644
--- a/port/cpl_vsil_s3.cpp
+++ b/port/cpl_vsil_s3.cpp
@@ -663,6 +663,9 @@ class VSIS3FSHandler final : public IVSIS3LikeFSHandler
 
     bool SupportsParallelMultipartUpload() const override { return true; }
 
+    bool SupportsSequentialWrite( const char* /* pszPath */, bool /* bAllowLocalTempFile */ ) override { return true; }
+    bool SupportsRandomWrite( const char* /* pszPath */, bool /* bAllowLocalTempFile */ ) override;
+
     std::string GetStreamingFilename(const std::string& osFilename) const override;
 };
 
@@ -2024,8 +2027,7 @@ VSIVirtualHandle* VSIS3FSHandler::Open( const char *pszFilename,
 
     if( strchr(pszAccess, 'w') != nullptr || strchr(pszAccess, 'a') != nullptr )
     {
-        if( strchr(pszAccess, '+') != nullptr &&
-            !CPLTestBool(CPLGetConfigOption("CPL_VSIL_USE_TEMP_FILE_FOR_RANDOM_WRITE", "NO")) )
+        if( strchr(pszAccess, '+') != nullptr && !SupportsRandomWrite(pszFilename, true) )
         {
             CPLError(CE_Failure, CPLE_AppDefined,
                         "w+ not supported for /vsis3, unless "
@@ -2084,6 +2086,16 @@ VSIVirtualHandle* VSIS3FSHandler::Open( const char *pszFilename,
         VSICurlFilesystemHandlerBase::Open(pszFilename, pszAccess, bSetError, papszOptions);
 }
 
+/************************************************************************/
+/*                        SupportsRandomWrite()                         */
+/************************************************************************/
+
+bool VSIS3FSHandler::SupportsRandomWrite( const char* /* pszPath */, bool bAllowLocalTempFile )
+{
+    return bAllowLocalTempFile &&
+           CPLTestBool(CPLGetConfigOption("CPL_VSIL_USE_TEMP_FILE_FOR_RANDOM_WRITE", "NO"));
+}
+
 /************************************************************************/
 /*                         ~VSIS3FSHandler()                            */
 /************************************************************************/
diff --git a/port/cpl_vsil_swift.cpp b/port/cpl_vsil_swift.cpp
index b1c08cef33..1e096bcca3 100644
--- a/port/cpl_vsil_swift.cpp
+++ b/port/cpl_vsil_swift.cpp
@@ -259,6 +259,9 @@ public:
         const char* GetOptions() override;
 
         std::string GetStreamingFilename(const std::string& osFilename) const override { return osFilename; }
+
+        bool SupportsSequentialWrite( const char* /* pszPath */, bool /* bAllowLocalTempFile */ ) override { return true; }
+        bool SupportsRandomWrite( const char* /* pszPath */, bool /* bAllowLocalTempFile */ ) override;
 };
 
 /************************************************************************/
@@ -298,8 +301,7 @@ VSIVirtualHandle* VSISwiftFSHandler::Open( const char *pszFilename,
 
     if( strchr(pszAccess, 'w') != nullptr || strchr(pszAccess, 'a') != nullptr )
     {
-        if( strchr(pszAccess, '+') != nullptr &&
-            !CPLTestBool(CPLGetConfigOption("CPL_VSIL_USE_TEMP_FILE_FOR_RANDOM_WRITE", "NO")) )
+        if( strchr(pszAccess, '+') != nullptr && !SupportsRandomWrite(pszFilename, true) )
         {
             CPLError(CE_Failure, CPLE_AppDefined,
                         "w+ not supported for /vsiswift, unless "
@@ -332,6 +334,16 @@ VSIVirtualHandle* VSISwiftFSHandler::Open( const char *pszFilename,
         VSICurlFilesystemHandlerBase::Open(pszFilename, pszAccess, bSetError, papszOptions);
 }
 
+/************************************************************************/
+/*                        SupportsRandomWrite()                         */
+/************************************************************************/
+
+bool VSISwiftFSHandler::SupportsRandomWrite( const char* /* pszPath */, bool bAllowLocalTempFile )
+{
+    return bAllowLocalTempFile &&
+           CPLTestBool(CPLGetConfigOption("CPL_VSIL_USE_TEMP_FILE_FOR_RANDOM_WRITE", "NO"));
+}
+
 /************************************************************************/
 /*                       ~VSISwiftFSHandler()                           */
 /************************************************************************/
diff --git a/port/cpl_vsil_unix_stdio_64.cpp b/port/cpl_vsil_unix_stdio_64.cpp
index 78fc7fbb45..79afc3c9c2 100644
--- a/port/cpl_vsil_unix_stdio_64.cpp
+++ b/port/cpl_vsil_unix_stdio_64.cpp
@@ -181,6 +181,10 @@ public:
     GIntBig GetDiskFreeSpace( const char* pszDirname ) override;
     int SupportsSparseFiles( const char* pszPath ) override;
 
+    bool IsLocal( const char* pszPath ) override;
+    bool SupportsSequentialWrite( const char* pszPath, bool /* bAllowLocalTempFile */ ) override;
+    bool SupportsRandomWrite( const char* pszPath, bool /* bAllowLocalTempFile */ ) override;
+
     VSIDIR* OpenDir( const char *pszPath, int nRecurseDepth,
                              const char* const *papszOptions) override;
 
@@ -888,6 +892,65 @@ int VSIUnixStdioFilesystemHandler::SupportsSparseFiles( const char*
 #endif
 }
 
+/************************************************************************/
+/*                          IsLocal()                                   */
+/************************************************************************/
+
+bool VSIUnixStdioFilesystemHandler::IsLocal( const char*
+#ifdef __linux
+                                                        pszPath
+#endif
+                                                        )
+{
+#ifdef __linux
+    struct statfs sStatFS;
+    if( statfs( pszPath, &sStatFS ) == 0 )
+    {
+        // See http://en.wikipedia.org/wiki/Comparison_of_file_systems
+        switch( static_cast<unsigned>(sStatFS.f_type) )
+        {
+            // Codes from http://man7.org/linux/man-pages/man2/statfs.2.html
+            case 0x6969U: // NFS
+            case 0x517bU: // SMB
+            case 0xff534d42U: // CIFS
+            case 0xfe534d42U: // SMB2 (https://github.com/libuv/libuv/blob/97dcdb1926f6aca43171e1614338bcef067abd59/src/unix/fs.c#L960)
+                return false;
+        }
+    }
+#else
+    static bool bMessageEmitted = false;
+    if( !bMessageEmitted )
+    {
+        CPLDebug("VSI",
+                 "Sorry: IsLocal() not implemented "
+                 "for this operating system");
+        bMessageEmitted = true;
+    }
+#endif
+    return true;
+}
+
+/************************************************************************/
+/*                    SupportsSequentialWrite()                         */
+/************************************************************************/
+
+bool VSIUnixStdioFilesystemHandler::SupportsSequentialWrite( const char* pszPath, bool /* bAllowLocalTempFile */ )
+{
+    VSIStatBufL sStat;
+    if( VSIStatL(pszPath, &sStat) == 0 )
+        return access(pszPath, W_OK) == 0;
+    return access(CPLGetDirname(pszPath), W_OK) == 0;
+}
+
+/************************************************************************/
+/*                     SupportsRandomWrite()                            */
+/************************************************************************/
+
+bool VSIUnixStdioFilesystemHandler::SupportsRandomWrite( const char* pszPath, bool /* bAllowLocalTempFile */ )
+{
+    return SupportsSequentialWrite(pszPath, false);
+}
+
 /************************************************************************/
 /*                            VSIDIRUnixStdio                           */
 /************************************************************************/
diff --git a/port/cpl_vsil_webhdfs.cpp b/port/cpl_vsil_webhdfs.cpp
index 163ac32427..017f29d5e8 100644
--- a/port/cpl_vsil_webhdfs.cpp
+++ b/port/cpl_vsil_webhdfs.cpp
@@ -108,6 +108,9 @@ public:
         const char* GetOptions() override;
 
         std::string GetStreamingFilename(const std::string& osFilename) const override { return osFilename; }
+
+        bool SupportsSequentialWrite( const char* /* pszPath */, bool /* bAllowLocalTempFile */ ) override { return true; }
+        bool SupportsRandomWrite( const char* /* pszPath */, bool /* bAllowLocalTempFile */ ) override;
 };
 
 /************************************************************************/
@@ -519,8 +522,7 @@ VSIVirtualHandle* VSIWebHDFSFSHandler::Open( const char *pszFilename,
 
     if( strchr(pszAccess, 'w') != nullptr || strchr(pszAccess, 'a') != nullptr )
     {
-        if( strchr(pszAccess, '+') != nullptr &&
-            !CPLTestBool(CPLGetConfigOption("CPL_VSIL_USE_TEMP_FILE_FOR_RANDOM_WRITE", "NO")) )
+        if( strchr(pszAccess, '+') != nullptr && !SupportsRandomWrite(pszFilename, true) )
         {
             CPLError(CE_Failure, CPLE_AppDefined,
                         "w+ not supported for /vsiwebhdfs, unless "
@@ -547,6 +549,16 @@ VSIVirtualHandle* VSIWebHDFSFSHandler::Open( const char *pszFilename,
         VSICurlFilesystemHandlerBase::Open(pszFilename, pszAccess, bSetError, papszOptions);
 }
 
+/************************************************************************/
+/*                        SupportsRandomWrite()                         */
+/************************************************************************/
+
+bool VSIWebHDFSFSHandler::SupportsRandomWrite( const char* /* pszPath */, bool bAllowLocalTempFile )
+{
+    return bAllowLocalTempFile &&
+           CPLTestBool(CPLGetConfigOption("CPL_VSIL_USE_TEMP_FILE_FOR_RANDOM_WRITE", "NO"));
+}
+
 /************************************************************************/
 /*                           GetOptions()                               */
 /************************************************************************/
diff --git a/port/cpl_vsil_win32.cpp b/port/cpl_vsil_win32.cpp
index ebd0398b9e..901f65706c 100644
--- a/port/cpl_vsil_win32.cpp
+++ b/port/cpl_vsil_win32.cpp
@@ -79,6 +79,7 @@ public:
                       { (void) pszFilename; return FALSE; }
     virtual GIntBig  GetDiskFreeSpace( const char* pszDirname ) override;
     virtual int SupportsSparseFiles( const char* pszPath ) override;
+    virtual bool      IsLocal( const char* pszPath ) override;
 };
 
 /************************************************************************/
@@ -1012,6 +1013,24 @@ int VSIWin32FilesystemHandler::SupportsSparseFiles( const char* pszPath )
     return (dwVolFlags & FILE_SUPPORTS_SPARSE_FILES);
 }
 
+/************************************************************************/
+/*                          IsLocal()                                   */
+/************************************************************************/
+
+bool VSIWin32FilesystemHandler::IsLocal( const char* pszPath)
+{
+    if( STARTS_WITH(pszPath, "\\\\" ) || STARTS_WITH(pszPath, "//" ) )
+        return false;
+    std::string osPath(pszPath);
+    if( osPath.size() >= 3 && osPath[1] == ':' &&
+        (osPath[2] == '\\' || osPath[2] == '/') )
+    {
+        osPath.resize( 3 );
+        return GetDriveType(osPath.c_str()) != DRIVE_REMOTE;
+    }
+    return true;
+}
+
 /************************************************************************/
 /*                     VSIInstallLargeFileHandler()                     */
 /************************************************************************/
